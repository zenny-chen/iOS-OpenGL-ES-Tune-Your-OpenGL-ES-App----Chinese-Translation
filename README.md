## 一般的性能推荐

使用常识对你的性能调优做出努力。比如，如果你的App每帧只绘制几十个三角形，那么改变它提交顶点数据的方式不可能提升其性能。为你的努力寻找提供最大性能提升的优化。

<br />

### 只有当场景数据改变时才重绘场景

你的App应该等待，直到在渲染新的一帧之前场景中的某些东西发生了改变。Core Animation cache了呈现给用户的最后一张图片，然后继续显示该图片，直到呈现新的一帧。

即便当你的数据发生改变时，也没必要以硬件处理命令的速度来渲染帧。一个更慢的，但固定的帧率常常会给用户呈现更顺滑的体验，比起更快的但不断改变的帧率。30帧每秒的固定帧率对于大部分动画是足够了，并且能帮助减少电源消耗。

<br />

### 禁用不使用的OpenGL ES特征

你的App不执行操作就是一种最好的计算。比如可以预先计算出一个结果，然后将它存储到你的模型数据中，你可以在运行时避免执行该计算。

如果你的App使用OpenGL ES 2.0或更高版本写的，那么不要创建一单个包含许多选择与条件语句的着色器代码来执行你的App所需要渲染当前帧而要做的每个任务。取而代之的是，编译多个着色器程序，每一个执行一个特定、专注的任务。

如果你的App使用OpenGL ES 1.1，那么禁用任何不需要在渲染当前场景中所用到的固定功能操作。比如，如果你的App不需要光照或颜色混合，那么就禁用这些功能。类似地，如果你的App只是绘制2D模型，那么它应该禁用雾和深度测试。

<br />

### 简化你的光照模型

这些准则既可应用到OpenGL ES 1.1的固定功能光照，也能应用到基于OpenGL ES 2.0或更高版本的基于着色器的光照计算。
・在你App中使用最少数量的光以及最简单的光照类型。考虑使用平行光来取代点光照，点光照需要更多的计算。着色器应该在模型空间中执行光照计算；考虑在你的着色器中使用更简单的光照方程而避免更复杂的光照算法。
・预先计算你的光照，然后将颜色值存储到一个纹理中，这样在片段着色器中可以直接对该纹理进行采样，而免去了光照计算。

<br />

## 高效地使用基于区块的延迟渲染

在所有iOS设备中所使用的GPU全都使用***基于区块的延迟渲染***（***Tile-based deferred rendering***），简称**TBDR**。当你调用OpenGL ES函数向硬件提交渲染命令时，这些命令会被缓存，直到积累了一张大的命令列表。直到你呈现了渲染缓存或冲刷，硬件才开始处理顶点并着色像素。硬件随后通过将帧缓存划分为若干区块作为一单个操作来渲染这些命令，然后针对每个区块对这些命令绘制一次。每个区块只渲染在它区域内可见的图元。（如果你使用`CAEAGLLayer`类创建了你自己的渲染缓存用于显示，那么你要使用OpenGL ES上下文的`presentRenderBuffer:`方法来呈现该渲染缓存。`glFlush`或`glFinish`函数将会冲刷命令缓存。）

因为区块存储器是GPU硬件的一部分，所以像深度测试以及颜色混合这样的渲染过程中的某些部分（在时间上和耗电上）比起传统的基于流的GPU架构要高效得多。因为基于区块渲染的架构对于一整个场景一次会处理所有顶点，所以GPU可以在处理片段之前就能执行隐藏面移除。不可见的像素将会被丢弃，而不会通过纹理采样与执行片段处理，这样大幅减少了GPU用于渲染区块所必须执行的计算量。

某些对于传统基于流的渲染器有用的渲染策略在iOS图形硬件上会有较高的性能成本。遵循下面所列出的准则可以帮你的App在TBDR的硬件上执行良好。

<br />

### 避免逻辑缓存加载与存储

当一个TBDR图形处理器开始渲染一个区块时，它必须先将帧缓存的那部分内容从共享存储器传输到GPU上的区块存储器。这种存储器传输称为一次*逻辑缓存加载*，这需要花费时间与电源。大部分情况下，一个帧缓存的之前内容没必要在下一帧绘制。每当你开始渲染一个新帧时通过调用`glClear`来避免加载之前缓存的性能成本。

类似地，当GPU完成渲染一个区块时，它必须将该区块的像素数据写回到共享存储器。这种传输称为*逻辑缓存存储*，它也有性能成本。对于每一帧的绘制，至少做这么一次传输是有必要的——呈现在屏幕上的颜色渲染缓存必须被传输到共享存储器，使得它可以通过Core Animation进行呈现。其他在你渲染算法中所使用的帧缓存附件（比如深度、模板、以及多重采样缓存）不需要被保留，因为它们的内容将会在下一帧的绘制中重建。OpenGL ES会自动将这些缓存存储到共享存储器中，这会导致性能成本，除非你显式地对他们进行***无效化***。要无效化一个缓存，在OpenGL ES 3.0中使用`glInvalidateFramebuffer`命令，在OpenGL ES 1.1跟2.0中则使用`glDiscardFramebufferEXT`命令。

如果你切换渲染目标，那么逻辑缓存的存储与加载操作也会发生。比如，如果你渲染到一个纹理，然后到视图的帧缓存，然后再次到同一个纹理，那么纹理的内容必须在共享存储器与GPU之间重复地传输。后备缓存你的绘制操作，使得所有绘制到一个渲染目标的操作被一起完成。当你切换帧缓存（使用`glBindFramebuffer`或`glFramebufferTexture2D`函数或`bindDrawable`方法）时，无效化不需要的帧缓存附件来避免引发一次逻辑缓存存储。

<br />

### 有效地使用隐藏面移除

一个TBDR图形处理器自动使用深度缓存对整个场景执行隐藏面移除，确保只有一个片段着色器对每个像素进行运行。减少片段处理的传统技术都是没必要的。比如，将对象或图元根据深度从前到后进行有效地排序**重复了**GPU所要完成的工作，而只会浪费CPU的时间。

当允许了颜色混合与alpha测试时，或者如果一个片段着色器使用`discard`指令或对`gl_FragDepth`输出变量进行写操作，那么GPU就不能执行隐藏面移除了。在这些情况下，GPU使用深度缓存无法决定一个片段的可见性，因此它必须为覆盖每一像素的所有图元运行片段着色器，这样要渲染一帧，就会极大地增加了所需要的时间和电源。为了避免这种性能成本，最少化对颜色混合、`discard`指令、以及写深度的使用。

如果你无法避免使用颜色混合、alpha测试、或丢弃指令，那么可以考虑以下策略来减少它们对性能的影响：
・用不透明度来排序物体。先绘制不透明的物体。接着绘制需要在片段着色器中使用`discard`操作（或在OpenGL ES 1.1中使用alpha测试）的物体。最后，绘制alpha混合的物体。
・对需要颜色混合或`discard`指令的对象进行裁剪，以减少要处理的片段个数。比如，不要绘制一个正方形来渲染一个包含许多空白空间的2D精灵纹理。取而代之的是，绘制一个更接近近似图片形状的多边形。下图展示了额外增加顶点处理的性能成本远低于运行不需要使用结果的片段着色器。
![屏幕快照 2018-11-25 下午10.13.43.png](https://upload-images.jianshu.io/upload_images/8136508-4d0e2aaef4e539e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
・在你的片段着色器中尽可能早地使用`discard`指令，以避免对不需要使用的结果执行计算。
・不要使用alpha测试或`discard`指令来抹杀像素，而是使用将alpha设置成零的alpha混合。颜色帧缓存没被修改，但硬件仍然可以使用它所执行的任何***Z缓存***（即**深度缓存**）优化。这确实会改变深度缓存中存储的值，并且也会需要对透明图元的从后到前的排序。
・如果你App的执行性能受到不可避免的丢弃操作的限制，那么可以考虑“**Z预解算**（**Z-Prepass**）”渲染策略。用一个简单的片段着色器对你的场景渲染一次，该片段着色器仅包含你的丢弃逻辑（避免昂贵的光照计算）对深度缓存进行填充。然后，使用`GL_EQUAL`深度测试函数以及你的光照着色器再次对你的场景进行渲染。尽管多遍渲染一般会导致性能处罚，但这个方法可以获得更好的性能，比起涉及大量丢弃操作的单遍渲染。

<br />

### 将OpenGL ES的命令组合起来用于高效的资源管理

当图形硬件在处理大场景时，上述提到的存储器带宽与计算量的节省能执行得最好。但是当硬件接收到的OpenGL ES命令要求它渲染较小的场景时，渲染器会损失较大的性能。比如，如果你的App使用一个纹理去渲染一批三角形，然后再修改这个纹理，那么OpenGL ES实现要么必须立即冲刷那些命令，要么复制该纹理，这两种方案都没有高效地使用硬件。类似地，任何企图对一个帧缓存读像素数据，都会要求之前的命令要被处理，如果这些命令会对该帧缓存进行修改的话。
为了避免这些性能处罚，将你的OpenGL ES调用顺序组织起来，使得对每一渲染目标的所有绘制命令能一起被执行。

<br />

## 最少化绘制命令的个数

每次当你的App提交图元被OpenGL ES处理时，CPU为图形硬件准备好命令。如果你的App使用了许多`glDrawArrays`或`glDrawElements`的调用来渲染一个场景，那么其性能可能会受到CPU资源的限制，从而无法充分利用GPU。

为了减少这个负荷，寻找一些方法将你的渲染合并为更少的绘制调用。有用的策略包括以下几点：
・将多个图元融合成一单个三角形条带。出于最佳结果，将所绘制的图元合并在近距离空间。大量的、不规则的模型对于你的App更难高效剔除，当它们在当前帧不可见时。
・创建**纹理图集**（**texture atlas**），使用同一纹理图像的不同部分来绘制多个图元。
・使用实例绘制（***instanced drawing***）来渲染许多类似的物体，如下所述。

<br />

### 使用实例绘制来最少化绘制调用

实例绘制命令允许你使用一单次绘制调用来多次绘制同样的顶点数据。你不需要花费CPU时间来设置一个网格（***mesh***）中不同实例之间的各个变种——比如这些实例的不同仅仅在于一个位置偏移、变换矩阵、颜色或纹理坐标等——从而要为每个实例发布一次绘制命令。而实例绘制则将各个实例变种的处理移置到了运行在GPU上的着色器代码中。

被重用多次的顶点数据对于实例绘制来说是主要候选。比如，列表7-3的代码在一个场景中在多个位置绘制了一个对象。然而，许多的`glUniform`和`glDrawArrays`调用增加了CPU负荷，从而降低了性能。
**列表7-3** 不使用实例来绘制许多类似的物体
```c
for (x = 0; x < 10; x++) {
    for (y = 0; y < 10; y++) {
        glUniform4fv(uniformPositionOffset, 1, positionOffsets[x][y]);
        glDrawArrays(GL_TRIANGLES, 0, numVertices);
    }
}
```

采用实例绘制需要两步：首先，将上述代码那样的循环替换为对`glDrawArraysInstanced`或`glDrawElementsInstanced`的单次调用。这个调用跟`glDrawArrays`或`glDrawElements`基本相同，只不过带有一个额外的形参来指定所要绘制的实例个数（比如列表7-3中有100个样本）。其次，选择OpenGL ES所提供的两种策略中的一个（即调用`glDrawArraysInstanced`还是`glDrawElementsInstanced`），在顶点着色器中使用每个实例的信息。

持有*着色器实例ID策略*之后，你的顶点着色器可以得到或查找到每个实例的信息。每次顶点着色器运行时，其内建的`gl_InstanceID`变量包含了一个数字用来标识当前正在绘制的实例。使用这个数可以在着色器代码中计算一个位置偏移、颜色或其他每个实例有所不同的属性，或在一个**uniform**数组或其他大块存储空间中用来查找每个实例的信息。比如，列表7-4使用了这个技术来绘制放置在10x10区域网格中的100个实例。

**列表7-4** OpenGL ES 3.0使用`gl_InstanceID`来计算每个实例信息的顶点着色器
```glsl
#version 300 es
 
in vec4 position;
 
uniform mat4 modelViewProjectionMatrix;
 
void main(void)
{
    float xOffset = float(gl_InstanceID % 10) * 0.5 - 2.5;
    float yOffset = float(gl_InstanceID / 10) * 0.5 - 2.5;
    vec4 offset = vec4(xOffset, yOffset, 0, 0);
 
    gl_Position = modelViewProjectionMatrix * (position + offset);
}
```

采用*实例数组*策略之后，你在一个顶点数组属性中存放每个实例的信息。你的顶点着色器然后可以访问那个属性以使用每个实例的信息。调用`glVertexAttribDivisor`函数来指定当OpenGL ES绘制每个实例时，那个属性会前进多少。其原型为：
```c
void glVertexAttribDivisor(GLuint index, GLuint divisor);
```
其中，参数`index`表示顶点属性的索引，即该属性对应于顶点着色器中的输入位置（in location）。参数`divisor`则表示顶点属性的前进频率。如果是0，那么对于每个顶点，该属性就会前进一次更新值（也就是不基于实例了，而是基于逐个顶点）；如果是1，那么对于每个实例，该属性会前进一次更新值；如果是2，那么表示每两个实例都用同一个属性值，到第3个实例时再让该属性前进，更新其值。
列表7-5描述了设置一个顶点数组用于实例绘制，而列表7-6则展示了相应的着色器代码。

**列表7-5** 为每个实例信息使用一个顶点属性
```c
#define kMyInstanceDataAttrib 5

glGenBuffers(1, &_instBuffer);
glBindBuffer(GL_ARRAY_BUFFER, _instBuffer);
glBufferData(GL_ARRAY_BUFFER, sizeof(instData), instData, GL_STATIC_DRAW);
glEnableVertexAttribArray(kMyInstanceDataAttrib);
glVertexAttribPointer(kMyInstanceDataAttrib, 2, GL_FLOAT, GL_FALSE, 0, 0);
// 这里指明了，对于每个实例都做一次前进，取用新的属性值
glVertexAttribDivisor(kMyInstanceDataAttrib, 1);
```

**列表7-6** OpenGL ES 3.0使用实例数组的顶点着色器
```c
#version 300 es

layout(location = 0) in vec4 position;
layout(location = 5) in vec2 inOffset;

uniform mat4 modelViewProjectionMatrix;

void main(void)
{
    vec4 offset = vec4(inOffset, 0.0, 0.0)
    gl_Position = modelViewProjectionMatrix * (position + offset);
}
```
实例绘制在核心OpenGL ES 3.0 API中可用，在OpenGL ES 2.0可以通过[EXT_draw_instanced](http://www.khronos.org/registry/gles/extensions/EXT/draw_instanced.txt)以及[EXT_instanced_arrays](http://www.khronos.org/registry/gles/extensions/EXT/EXT_instanced_arrays.txt)扩展来使用。

<br />

## 最小化OpenGL ES存储器使用

你的iOS App与系统和其他iOS App一起共享主存储器。用于OpenGL ES而分配的存储器会减少你App中可做他用的存储器。因此要记住，仅分配你所需要的存储器，并且在你App不再需要的时候就释放它。这里有一些方法可帮你节省存储器：
・在将一个图片加载到OpenGL ES纹理之后，释放原始图片。
・只有当你App需要的时候再去分配深度缓存。
・如果你的App不立刻需要所有资源，那么仅加载这些资源项的一个子集。比如，一个游戏可能会被划分为好几个关卡；以一个更严格的资源限制来做对总和资源的每次加载的子集。

iOS中的虚拟存储器系统没有使用交换文件。当系统检测到很少存储器可使用时，虚拟存储器并不是将易挥发页写到磁盘，而是释放掉非挥发存储器，将你当前运行的App所需要的存储器分配给你。你的App应该尽可能地少使用存储器，并且为处理好对你当前运行的App没必要的对象做好准备。

<br />

## 要意识到Core Animation合成的性能

Core Animation将渲染缓存的内容与你视图层级中其他图层进行合成，不管这些图层是否使用了OpenGL ES、Quartz或是其他图形库所绘制出来的。这个是很有帮助的，因为它意味着OpenGL ES是Core Animation中的头等公民。然而，将OpenGL ES内容与其他内容进行混合需要花费时间；当不恰当使用的话，你的App可能会执行非常慢以至于无法达到可交互的帧率。
对于绝对的最佳性能，你的App应当单单仅依赖于OpenGL ES来渲染你的内容。将存放你OpenGL ES内容的视图放大到与屏幕尺寸一样，确保其`opaque`属性被设置为`YES`，并且没有其他的视图或Core Animation图层可见。如果你所渲染到的一个Core Animation图层被合成到其他图层的顶部，将你的`CAEAGLLayer`对象变为不透明能减少（但不能消除）性能成本。如果你的`CAEAGLLayer`对象作为顶部图层并且与它下面的图层进行颜色混合，那么渲染缓存的颜色数据必须用一种**预先乘好的**（***premultiplied***）alpha格式用Core Animation进行正确地合成。将顶部的OpenGL ES内容与其他内容进行混合会有严重的性能处罚。
